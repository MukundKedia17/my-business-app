<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    
    <!-- Instructions for Mobile App Experience -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="ERP App">
    <link rel="apple-touch-icon" href="https://placehold.co/180x180/818cf8/ffffff?text=ERP">
    
    <title>Business ERP Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script type="module">
        // --- Firebase Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, query, where, orderBy, doc, setDoc, getDocs, deleteDoc, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Permanent, Live Firebase Configuration ---
        // Yeh aapke app ka naya, permanent, aur live database hai.
        const firebaseConfig = {
          apiKey: "AIzaSyA_...REPLACE_WITH_YOUR_OWN_CONFIG", // Replace with your actual Firebase config
          authDomain: "business-erp-app-mukund.firebaseapp.com",
          projectId: "business-erp-app-mukund",
          storageBucket: "business-erp-app-mukund.appspot.com",
          messagingSenderId: "101...",
          appId: "1:101...:web:..."
        };

        // --- Global State ---
        let userId;
        let transactions = [];
        let products = [
            { id: 'prod001', name: 'White Phenyl', standardCost: 50 },
            { id: 'prod002', name: 'Toilet Cleaner', standardCost: 60 },
            { id: 'prod003', name: 'Handwash', standardCost: 40 }
        ];
        let parties = [];
        let db, auth;

        // --- Main Initialization on Page Load ---
        document.addEventListener('DOMContentLoaded', () => {
            const statusBar = document.getElementById('status-bar');

            try {
                statusBar.textContent = "Connecting to your secure database...";
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, async user => {
                    if (user) {
                        userId = user.uid;
                        statusBar.textContent = "Connection successful. Loading dashboard...";
                        initDashboard();
                        statusBar.classList.remove('bg-blue-100', 'text-blue-800');
                        statusBar.classList.add('bg-green-100', 'text-green-800');
                        setTimeout(() => { statusBar.classList.add('hidden'); }, 2000);
                    } else {
                         statusBar.textContent = "Creating a secure session for you...";
                         await signInAnonymously(auth);
                    }
                });
            } catch (error) {
                 statusBar.innerHTML = `<h3 class="font-bold">Critical Error</h3><p>${error.message}</p>`;
                 statusBar.classList.add('bg-red-100', 'text-red-800');
            }
        });

        function initDashboard() {
            setupTabSwitching();
            setupListeners();
            document.getElementById('dataEntryForm').addEventListener('submit', (e) => handleDataEntry(e));
            document.getElementById('allTransactionsTableBody').addEventListener('click', (e) => handleTableActions(e));
            document.getElementById('partyLedgerSelect').addEventListener('change', (e) => renderPartyLedger(e.target.value));
            document.getElementById('chatbotForm').addEventListener('submit', (e) => handleChatbotInput(e));
        }

        function setupTabSwitching() {
            const tabs = document.querySelectorAll('.tab-btn');
            const tabContents = document.querySelectorAll('.tab-content');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('bg-indigo-600', 'text-white'));
                    tab.classList.add('bg-indigo-600', 'text-white');
                    const target = tab.dataset.tab;
                    tabContents.forEach(content => { content.classList.toggle('hidden', content.id !== target); });
                });
            });
            if(document.getElementById('dataEntryTab')) { document.getElementById('dataEntryTab').click(); }
        }
        
        function getCollectionPath(collectionName) {
            return `users/${userId}/${collectionName}`;
        }
        
        function setupListeners() {
            if (!userId) return;
            populateProductDropdowns();
            const transactionsCol = collection(db, getCollectionPath('transactions'));
            const q = query(transactionsCol, orderBy('date', 'desc'));
            onSnapshot(q, (snapshot) => {
                transactions = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                updateAllTabs();
            });
            const partiesCol = collection(db, getCollectionPath('parties'));
            onSnapshot(query(partiesCol), (snapshot) => {
                parties = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                populatePartyLedgerDropdown();
            });
        }
        
        function updateAllTabs() {
            renderAllTransactionsTable();
            renderSalesReports();
            renderInventoryReport();
            renderUnitEconomics();
            renderFinancialStatements();
        }

        async function handleDataEntry(e) {
            e.preventDefault();
            if (!userId) { alert('Authentication not ready.'); return; }
            
            const form = e.target;
            const transactionId = form.editTransactionId.value;

            const transaction = {
                date: form.date.value, type: form.type.value,
                product: form.product.value, quantity: parseInt(form.quantity.value) || 0,
                amount: parseFloat(form.amount.value), party: form.party.value.trim(),
                description: form.description.value || form.type.value
            };

            if (transactionId) {
                const transactionRef = doc(db, getCollectionPath('transactions'), transactionId);
                await updateDoc(transactionRef, transaction);
                await deleteJournalEntriesForTransaction(transactionId);
                await createJournalEntries(transaction, transactionId);
                showNotification('Transaction updated successfully!');
            } else {
                const transactionsCol = collection(db, getCollectionPath('transactions'));
                const docRef = await addDoc(transactionsCol, transaction);
                await createJournalEntries(transaction, docRef.id);
                await updateParty(transaction.party, transaction.type);
                showNotification('Transaction saved successfully!');
            }
            
            resetForm();
        }

        function renderAllTransactionsTable() {
            const tableBody = document.getElementById('allTransactionsTableBody');
            tableBody.innerHTML = '';
            transactions.forEach(tx => {
                tableBody.innerHTML += `<tr class="border-b hover:bg-gray-50"><td class="py-2 px-3 text-xs">${tx.date}</td><td class="py-2 px-3">${tx.type.charAt(0).toUpperCase() + tx.type.slice(1)}</td><td class="py-2 px-3">${tx.description}</td><td class="py-2 px-3 text-right">₹${tx.amount.toFixed(2)}</td>
                <td class="py-2 px-3 text-center space-x-2">
                    <button data-id="${tx.id}" class="modify-btn text-blue-500 hover:text-blue-700 text-xs font-medium">Modify</button>
                    <button data-id="${tx.id}" class="delete-btn text-red-500 hover:text-red-700 text-xs font-medium">Delete</button>
                </td></tr>`;
            });
        }
        
        async function handleTableActions(e) {
            const target = e.target;
            const txId = target.dataset.id;
            if (!txId) return;

            if (target.classList.contains('delete-btn')) {
                await deleteJournalEntriesForTransaction(txId);
                await deleteDoc(doc(db, getCollectionPath('transactions'), txId));
                showNotification('Transaction deleted successfully!', 'bg-red-500');

            } else if (target.classList.contains('modify-btn')) {
                const txToModify = transactions.find(t => t.id === txId);
                if (txToModify) {
                    const form = document.getElementById('dataEntryForm');
                    form.date.value = txToModify.date;
                    form.type.value = txToModify.type;
                    form.party.value = txToModify.party;
                    form.product.value = txToModify.product;
                    form.quantity.value = txToModify.quantity;
                    form.amount.value = txToModify.amount;
                    form.description.value = txToModify.description;
                    form.editTransactionId.value = txId;
                    form.querySelector('button[type="submit"]').textContent = 'Update Transaction';
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
            }
        }
        
        async function deleteJournalEntriesForTransaction(txId) {
            const journalCol = collection(db, getCollectionPath('journal'));
            const q = query(journalCol, where('transactionId', '==', txId));
            const journalSnapshot = await getDocs(q);
            const deletePromises = [];
            journalSnapshot.forEach(doc => deletePromises.push(deleteDoc(doc.ref)));
            await Promise.all(deletePromises);
        }

        function resetForm() {
            const form = document.getElementById('dataEntryForm');
            form.reset();
            form.editTransactionId.value = '';
            form.querySelector('button[type="submit"]').textContent = 'Save Transaction';
            document.getElementById('date').valueAsDate = new Date();
        }

        async function handleChatbotInput(e) {
            e.preventDefault();
            const input = document.getElementById('chatbotInput');
            const text = input.value.trim();
            if (!text) return;

            addChatMessage('user', text);
            const parsedTx = parseTransactionFromText(text);

            if (parsedTx.error) {
                addChatMessage('bot', `Sorry, I couldn't understand. ${parsedTx.error}`);
            } else {
                const confirmationMsg = `OK, I've recorded: ${parsedTx.type} of ${parsedTx.quantity} ${parsedTx.product} for ₹${parsedTx.amount.toFixed(2)} on ${parsedTx.date}.`;
                addChatMessage('bot', confirmationMsg);
                
                const transactionsCol = collection(db, getCollectionPath('transactions'));
                const docRef = await addDoc(transactionsCol, parsedTx);
                await createJournalEntries(parsedTx, docRef.id);
                await updateParty(parsedTx.party, parsedTx.type);
                showNotification('Transaction saved via Chatbot!');
            }
            input.value = '';
        }

        function parseTransactionFromText(text) {
            text = text.toLowerCase();
            let type, product, quantity, amount, party = '', date = new Date();

            const saleWords = ['sell', 'sold', 'becha', 'deliver'];
            const purchaseWords = ['buy', 'bought', 'purchase', 'khrida', 'purchased from', 'get from'];

            if (saleWords.some(word => text.includes(word))) { type = 'sale';
            } else if (purchaseWords.some(word => text.includes(word))) { type = 'purchase';
            } else { return { error: "Please use words like 'buy', 'sell', 'purchase', 'deliver'." }; }

            if (text.includes('tomorrow') || text.includes('kal')) { date.setDate(date.getDate() + 1);
            } else if (text.includes('yesterday')) { date.setDate(date.getDate() - 1);
            } else {
                const dateMatch = text.match(/on\s(\d{1,2})(?:st|nd|rd|th)?\s(\w+)/);
                if (dateMatch) {
                    const day = parseInt(dateMatch[1], 10);
                    const monthName = dateMatch[2];
                    const monthIndex = new Date(Date.parse(monthName + " 1, 2024")).getMonth();
                    if (monthIndex >= 0) { date = new Date(new Date().getFullYear(), monthIndex, day); }
                }
            }
            const finalDateString = date.toISOString().split('T')[0];

            const foundProduct = products.find(p => text.includes(p.name.toLowerCase()));
            if (!foundProduct) { return { error: `Product not found. Try: ${products.map(p=>p.name).join(', ')}.` }; }
            product = foundProduct.name;

            const toMatch = text.match(/(?:to|for)\s([\w\s]+?)(?=\s@|\sfor|\sonline|\s$)/);
            const fromMatch = text.match(/from\s([\w\s]+?)(?=\s@|\sfor|\s$)/);

            if (type === 'sale' && toMatch) {
                party = toMatch[1].replace(product.toLowerCase(), '').trim().replace(/\b\w/g, l => l.toUpperCase());
            } else if (type === 'purchase' && fromMatch) {
                party = fromMatch[1].replace(product.toLowerCase(), '').trim().replace(/\b\w/g, l => l.toUpperCase());
            }

            const pattern1 = /(\d+)\s*.*?\s*@\s*(\d+(\.\d+)?)/; 
            const pattern2 = /(\d+)\s*.*?\s*for\s*(\d+(\.\d+)?)/;

            let match;
            if ((match = text.match(pattern1))) {
                quantity = parseInt(match[1], 10);
                const pricePerUnit = parseFloat(match[2]);
                amount = quantity * pricePerUnit;
            } else if ((match = text.match(pattern2))) {
                quantity = parseInt(match[1], 10);
                amount = parseFloat(match[2]);
            } else {
                 const numbers = text.match(/\d+(\.\d+)?/g)?.map(Number) || [];
                 if(numbers.length < 2) return { error: "Please provide both quantity and price/amount." };
                 quantity = numbers[0];
                 amount = numbers[1];
            }
            
            if (!quantity || !amount) return { error: "Could not determine quantity or amount." };

            return { date: finalDateString, type, product, quantity, amount, party, description: `Chatbot Entry: ${text}` };
        }

        function addChatMessage(sender, message) {
            const chatbox = document.getElementById('chatbox');
            const bubble = document.createElement('div');
            bubble.textContent = message;
            if (sender === 'user') { bubble.className = 'bg-indigo-500 text-white p-2 rounded-lg self-end max-w-xs mb-2';
            } else { bubble.className = 'bg-gray-200 text-gray-800 p-2 rounded-lg self-start max-w-xs mb-2'; }
            chatbox.appendChild(bubble);
            chatbox.scrollTop = chatbox.scrollHeight;
        }

        function getAvgCostForProduct(productName) {
            const purchases = transactions.filter(t => t.type === 'purchase' && t.product === productName);
            if (purchases.length === 0) return products.find(p=>p.name === productName)?.standardCost || 0;
            const totalCost = purchases.reduce((sum, t) => sum + t.amount, 0);
            const totalQty = purchases.reduce((sum, t) => sum + t.quantity, 0);
            return totalQty > 0 ? totalCost / totalQty : 0;
        }

        function renderInventoryReport() {
            const inventoryBody = document.getElementById('inventoryReportBody');
            inventoryBody.innerHTML = '';
            let grandTotalValue = 0;
            products.forEach(product => {
                const purchases = transactions.filter(t => t.type === 'purchase' && t.product === product.name).reduce((sum, t) => sum + t.quantity, 0);
                const sales = transactions.filter(t => t.type === 'sale' && t.product === product.name).reduce((sum, t) => sum + t.quantity, 0);
                const closingStock = purchases - sales;
                const avgCost = getAvgCostForProduct(product.name);
                const stockValue = closingStock * avgCost;
                grandTotalValue += stockValue;
                inventoryBody.innerHTML += `<tr class="border-b"><td class="py-2 px-4 font-medium">${product.name}</td><td class="py-2 px-4 text-center">${purchases}</td><td class="py-2 px-4 text-center text-red-600">${sales}</td><td class="py-2 px-4 text-center font-bold">${closingStock}</td><td class="py-2 px-4 text-right">₹${stockValue.toFixed(2)}</td></tr>`;
            });
            document.getElementById('totalInventoryValue').textContent = `₹${grandTotalValue.toFixed(2)}`;
        }

        function renderUnitEconomics() {
            const economicsBody = document.getElementById('unitEconomicsBody');
            economicsBody.innerHTML = '';
            products.forEach(product => {
                const salesTx = transactions.filter(t => t.type === 'sale' && t.product === product.name);
                const totalRevenue = salesTx.reduce((sum, t) => sum + t.amount, 0);
                const totalQtySold = salesTx.reduce((sum, t) => sum + t.quantity, 0);
                const avgSellPrice = totalQtySold > 0 ? totalRevenue / totalQtySold : 0;
                
                const avgCostPrice = getAvgCostForProduct(product.name);
                
                const profit = avgSellPrice - avgCostPrice;
                const margin = avgSellPrice > 0 ? (profit / avgSellPric

